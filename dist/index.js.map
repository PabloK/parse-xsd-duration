{"version":3,"sources":["../src/index.js"],"names":["UNITS","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","YEAR_UNIT","MONTH_UNIT","DAY_UNIT","HOUR_UNIT","MINUTE_UNIT","SECOND_UNIT","IS_NEGATIVE_UNIT","emptyPeriod","emptyTime","isValidXsdDuration","str","test","isNonEmptyString","input","length","isNegative","stripFirstChar","slice","unitToSeconds","unit","amount","toUpperCase","parseUnit","amt","getNumber","parseFloat","isNaN","parsePeriod","period","exec","year","month","day","parsePeriodToObject","years","months","days","parseTime","time","hour","minute","second","parseTimeToObject","hours","minutes","seconds","parse","neg","duration","splitDuration","split","output","convertToObject","Object","assign","out","toObject","TypeError"],"mappings":"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","file":"index.js","sourcesContent":["const UNITS = {\n  YEAR: 31536000,\n  MONTH: 2628000,\n  DAY: 86400,\n  HOUR: 3600,\n  MINUTE: 60,\n  SECOND: 1\n}\n\nconst YEAR_UNIT = 'years'\nconst MONTH_UNIT = 'months'\nconst DAY_UNIT = 'days'\nconst HOUR_UNIT = 'hours'\nconst MINUTE_UNIT = 'minutes'\nconst SECOND_UNIT = 'seconds'\nconst IS_NEGATIVE_UNIT = 'isNegative'\n\nconst emptyPeriod = {\n  [YEAR_UNIT]: 0,\n  [MONTH_UNIT]: 0,\n  [DAY_UNIT]: 0\n}\n\nconst emptyTime = {\n  [HOUR_UNIT]: 0,\n  [MINUTE_UNIT]: 0,\n  [SECOND_UNIT]: 0\n}\n\n// Regex taken from https://www.w3.org/TR/xmlschema11-2/#duration-lexical-space\nconst isValidXsdDuration = (str) => /^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$/.test(str)\nconst isNonEmptyString = (input) => (typeof input === 'string' && input.length > 0)\nconst isNegative = (str) => str[0] === '-'\nconst stripFirstChar = (str) => str.slice(1)\nconst unitToSeconds = (unit, amount) => UNITS[unit.toUpperCase()] * amount\n\nconst parseUnit = (unit, amount) => {\n  const amt = getNumber(amount)\n  return unitToSeconds(unit, amt)\n}\n\nconst getNumber = (amount) => {\n  const amt = parseFloat(amount)\n  if (isNaN(amt)) return 0\n  return amt\n}\n\nconst parsePeriod = (period) => {\n  const [, year, month, day] = ((/^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g).exec(period) || [])\n\n  return parseUnit('year', year) +\n    parseUnit('month', month) +\n    parseUnit('day', day)\n}\n\nconst parsePeriodToObject = (period) => {\n  const [, years, months, days] = ((/^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g).exec(period) || [])\n\n  return {\n    [YEAR_UNIT]: getNumber(years),\n    [MONTH_UNIT]: getNumber(months),\n    [DAY_UNIT]: getNumber(days)\n  }\n}\n\nconst parseTime = (time) => {\n  const [, hour, minute, second] = ((/^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g).exec(time) || [])\n\n  return parseUnit('hour', hour) +\n    parseUnit('minute', minute) +\n    parseUnit('second', second)\n}\n\nconst parseTimeToObject = (time) => {\n  const [, hours, minutes, seconds] = ((/^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g).exec(time) || [])\n\n  return {\n    [HOUR_UNIT]: getNumber(hours),\n    [MINUTE_UNIT]: getNumber(minutes),\n    [SECOND_UNIT]: getNumber(seconds)\n  }\n}\n\nconst parse = (str) => {\n  const neg = isNegative(str)\n  const duration = neg ? stripFirstChar(str) : str\n  const splitDuration = duration.split('T')\n  const period = stripFirstChar(splitDuration[0])\n  const time = splitDuration[1]\n\n  let output = 0\n  if (isNonEmptyString(period)) output += parsePeriod(period)\n  if (isNonEmptyString(time)) output += parseTime(time)\n  return neg ? -output : output\n}\n\nexport const convertToObject = (str) => {\n  const neg = isNegative(str)\n  const duration = neg ? stripFirstChar(str) : str\n  const splitDuration = duration.split('T')\n  const period = stripFirstChar(splitDuration[0])\n  const time = splitDuration[1]\n\n  let output = {[IS_NEGATIVE_UNIT]: neg}\n  output = isNonEmptyString(period) ? Object.assign(output, parsePeriodToObject(period)) : Object.assign(output, emptyPeriod)\n  output = isNonEmptyString(time) ? Object.assign(output, parseTimeToObject(time)) : Object.assign(output, emptyTime)\n  return output\n}\n\nconst out = (input, toObject = false) => {\n  // Throw error for non-string input\n  if (typeof input !== 'string') {\n    throw new TypeError('expected input to be a string')\n  }\n  // Return null for invalid input\n  if (!isValidXsdDuration(input)) return null\n  // Parse valid input\n  return toObject ? convertToObject(input) : parse(input)\n}\n\nexport default (input, toObject) => out(input, toObject)\n"]}